<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_p1_fIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//add player to global player unit list
PVP = false;
scr_views();


ds_list_add(global.player_units, self);

alive = true;
str = 7;
intel = 4;
agi = 4;

hpmax = floor(str * 2) + floor(intel * 1.33) + floor(agi * 1.5);
hp = hpmax;
hppercent = 100;
p = 0;
speed = 0;
startUpCounter = 0;
dir = "up";
state = "notarget";
substate = "idle";
animation = "false";
depth = -y;
p1TargetDir = 0;
targetFace = "up";
guardDir = "middle";
animationCounter = 0;
tempState = "idle";

parryCounter = 10;
blockCounter = 20;
dodgeCounter = 0;
grabCounter = 10;
grabbingCounter = 30;

heavyArmor = 0;
heavyArmorDelay = 0;

last_sprite = 0;
damagePending = 0;

//This keeps track of subimage while animating

animatingImage = 0;

// target list from enemies that are active

global.p1_enemies = ds_list_create();

//hitbox and hurtbox code

//hurtbox
hurtbox = scr_create_hurtbox(26,48,-13,-20);

//hitbox
hitbox = -1;

hit = false;
hitStun = 0;
hitBy = -1;

//alarm information
/*
alarm[0]= -1; //this is the parry alarm
alarm[1] = -1 //this is the block alarm
*/


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//hurtbox
with(hurtbox){
    x = other.x + xOffset;
    y = other.y + yOffset;
}


//hitbox
if(hitbox != -1){
    with(hitbox){
        x = other.x + xOffset;
        y = other.y + yOffset;

        //check to see if the hurtbox is touching your hitbox        
        with(obj_hurtbox){
            if(place_meeting(x,y,other) &amp;&amp; other.owner != owner){
                //ignore check
                //checking collision from the hitbox object
                with(other){
                    //check to see if your target is on the ignore list
                    //if it is on the ignore list, dont hit it again
                    for(i = 0; i &lt; ds_list_size(ignoreList); i ++){
                        if(ignoreList[|i] = other.owner){
                            ignore = true;
                            break;
                        }
                    }

                    //if it is NOT on the ignore list, hit it, and add it to
                    //the ignore list
                    if(!ignore){
                        other.owner.hit = true;
                        other.owner.hitBy = id;
                         other.owner.damagePending = damage;
                        ds_list_add(ignoreList,other.owner);
                    }
                }
            }
        }
    }
}



//momentum

if (p &lt;= 0){
      p = 0;
    }
// animation counter:




if (animationCounter &gt; 0)
    {
    animationCounter = animationCounter - 1;
    }
    
if (animationCounter = 1)
    {
     animation = "false";
     substate = tempState;
    }
    
    if (startUpCounter &gt; 0)
{
startUpCounter = startUpCounter - 1;

} 

 /* -------------------------------------------------------------------------------------
 
 Directional key release controls
 
 ----------------------------------------------------------------------------------------*/
 
 if (!up_held and !down_held and !left_held and !right_held and !animation){
    
    switch(state){
        case "target":
            substate = "guard";
        break;
        
        case "notarget":
            substate = "idle";
        break;
        }
 
    }
 
 
 
 
 
 
 
 
 
 
 /*
 if (left_released) //statements for what happens when you release a key
 {
 //switch statement for each possible main state, that is targeting or not targeting. There should be some overlapping actions that can be done in either.
  switch(state)
    {
    
    //notarget case
    
      case("notarget"):
        {
        
        //switch on substate for "notarget"
        
        switch(substate)
            {
             case "idle":
                {
                //should almost never happen, but null if it does
                }
              case "startup":
                {
               substate = "idle";
                }
             case "walk":
                {
               substate = "idle";
                }
            case "sprint":
                {
                //sprint script. Same as walking, but with more stopping animation, but maintain sprint(sprint will be toggle methinks)
                }
            case "sleep":
                {
                //sleep script. Wake up and begin walking.
                }
            case "sneak":
                {
                //sneak script. sneak in direction pressed
                }
            case "dialogue":
                {
                //dialouge script. movement keys should do nothing
                }
            case "menu":
                {
                //menu script. Navigate menus
                }
            case "hitstun":
                {
                //hitstun script. don't move left
                }
            }
        }
        
        
    //target case
      case("target"):
        {
        //switch on substate for "target"
            switch(substate)
                {
                
                  case "guard":
                    {
                    //guard script
                    }
                  case "strafe":
                    {
                     substate = "guard";
                    }
                  case "sprint":
                    {
                    //sprint script
                    }
                  case "attack":
                    {
                   //attack script
                    }
                  case "dash":
                     {
                   //dash script
                    }
                  case "cast":
                    {
                        //cast script
                    }
                  case "shoot":
                    {
                    //shoot script
                    }
                }
        
        }   
        
        
    }
  }
    
    if (up_released) //need to have if statement for when key is released to return to "idle" substate for both target and no target modes.
 {
 
 //switch statement for each possible main state, that is targeting or not targeting. There should be some overlapping actions that can be done in either.
  switch(state)
    {
    
    //notarget case
    
      case("notarget"):
        {
        
        //switch on substate for "notarget"
        
        switch(substate)
            {
             case "idle":
                {
                //should almost never happen, but null if it does
                }
              case "startup":
                {
               substate = "idle";
                }
            case "walk":
                {
               substate = "idle";
                }
            case "sprint":
                {
                //sprint script. Same as walking, but with more stopping animation, but maintain sprint(sprint will be toggle methinks)
                }
            case "sleep":
                {
                //sleep script. Wake up and begin walking.
                }
            case "sneak":
                {
                //sneak script. sneak in direction pressed
                }
            case "dialogue":
                {
                //dialouge script. movement keys should do nothing
                }
            case "menu":
                {
                //menu script. Navigate menus
                }
            case "hitstun":
                {
                //hitstun script. don't move left
                }
            }
        }
        
        
    //target case
      case("target"):
        {
        //switch on substate for "target"
            switch(substate)
                {
                
                  case "guard":
                    {
                    //guard script
                    }
                  case "strafe":
                    {
                     substate = "guard";
                    }
                  case "sprint":
                    {
                    //sprint script
                    }
                  case "attack":
                    {
                   //attack script
                    }
                  case "dash":
                     {
                   //dash script
                    }
                  case "cast":
                    {
                        //cast script
                    }
                  case "shoot":
                    {
                    //shoot script
                    }
                }
        
        }   
        
        
    }
 }  
    
  if (right_released) //need to have if statement for when key is released to return to "idle" substate for both target and no target modes.
 {
 
 //switch statement for each possible main state, that is targeting or not targeting. There should be some overlapping actions that can be done in either.
  switch(state)
    {
    
    //notarget case
    
      case("notarget"):
        {
        
        //switch on substate for "notarget"
        
        switch(substate)
            {
             case "idle":
                {
                //should almost never happen, but null if it does
                }
              case "startup":
                {
               substate = "idle";
                }
            case "walk":
                {
               substate = "idle";
                }
            case "sprint":
                {
                //sprint script. Same as walking, but with more stopping animation, but maintain sprint(sprint will be toggle methinks)
                }
            case "sleep":
                {
                //sleep script. Wake up and begin walking.
                }
            case "sneak":
                {
                //sneak script. sneak in direction pressed
                }
            case "dialogue":
                {
                //dialouge script. movement keys should do nothing
                }
            case "menu":
                {
                //menu script. Navigate menus
                }
            case "hitstun":
                {
                //hitstun script. don't move left
                }
            }
        }
        
        
    //target case
      case("target"):
        {
        //switch on substate for "target"
            switch(substate)
                {
                
                  case "guard":
                    {
                    //guard script
                    }
                  case "strafe":
                    {
                     substate = "guard";
                    }
                  case "sprint":
                    {
                    //sprint script
                    }
                  case "attack":
                    {
                   //attack script
                    }
                  case "dash":
                     {
                   //dash script
                    }
                  case "cast":
                    {
                        //cast script
                    }
                  case "shoot":
                    {
                    //shoot script
                    }
                }
        
        }   
        
        
    }
  }  
 
if (down_released) //need to have if statement for when key is released to return to "idle" substate for both target and no target modes.
 {
 
 //switch statement for each possible main state, that is targeting or not targeting. There should be some overlapping actions that can be done in either.
  switch(state)
    {
    
    //notarget case
    
      case("notarget"):
        {
        
        //switch on substate for "notarget"
        
        switch(substate)
            {
            case "idle":
                {
                //should almost never happen, but null if it does
                }
             case "startup":
                {
               substate = "idle";
                }
            case "walk":
                {
               substate = "idle";
                }
            case "sprint":
                {
                //sprint script. Same as walking, but with more stopping animation, but maintain sprint(sprint will be toggle methinks)
                }
            case "sleep":
                {
                //sleep script. Wake up and begin walking.
                }
            case "sneak":
                {
                //sneak script. sneak in direction pressed
                }
            case "dialogue":
                {
                //dialouge script. movement keys should do nothing
                }
            case "menu":
                {
                //menu script. Navigate menus
                }
            case "hitstun":
                {
                //hitstun script. don't move left
                }
            }
        }
        
        
    //target case
      case("target"):
        {
        //switch on substate for "target"
            switch(substate)
                {
                
                  case "guard":
                    {
                    //guard script
                    }
                  case "strafe":
                    {
                     substate = "guard";
                    }
                  case "sprint":
                    {
                    //sprint script
                    }
                  case "attack":
                    {
                   //attack script
                    }
                  case "dash":
                     {
                   //dash script
                    }
                  case "cast":
                    {
                        //cast script
                    }
                  case "shoot":
                    {
                    //shoot script
                    }
                }
        
        }   
        
        
    }
  }
  */
  
  
   /* ------------------------------------------------------------------------------------------------------------------------
 
 Attack Codes
 
 --------------------------------------------------------------------------------------------------------------------------*/
if(state == "notarget"){
 
 if (r1_pressed and animation = "false")
    {
    
    script_execute(scr_melee_light_attack, dir, state, substate, p1TargetDir, targetFace, guardDir);
    
    
     p = 8;
     scr_block_cancel();

    }
    }
if(state == "notarget"){
 
 if (r2_pressed and animation = "false")
    {
    
    script_execute(scr_melee_heavy_attack, dir, state, substate, p1TargetDir, targetFace, guardDir);
    
    
     p = 8;
     scr_block_cancel();

    }
    }
if(state == "target"){

    if (r1_pressed and animation = "false")
    {
     scr_block_cancel();
    script_execute(scr_melee_light_attack, dir, state, substate, p1TargetDir, targetFace, guardDir);
    
    if(distance_to_object(p1_target) &lt; 64) { p = 2 + sqrt(distance_to_object(p1_target));}
    
    else{ p = 8;}

    }

}
if(state == "target"){

    if (r2_pressed and animation = "false")
    {
     scr_block_cancel();
    script_execute(scr_melee_heavy_attack, dir, state, substate, p1TargetDir, targetFace, guardDir);
    
    if(distance_to_object(p1_target) &lt; 64) { p = 2 + sqrt(distance_to_object(p1_target));}
    
    else{ p = 8;}

    }

}

//make sure the sprite is starting at the first sub image
    
if (last_sprite != sprite_index) {
   image_index = 0;
   last_sprite = sprite_index;
}
//catch this ensures if they target after they throw an attack that the substate sets to gaurd
if(substate == "idle" and state == "target") {substate = "guard";}

/*-----------------------------------------------------------------------------------------------------

Hit/Hurtbox management

----------------------------------------------------------------------------------------------------------*/


//-------
//Light Attack Hit Box Creation
//-------------



//no target


if (state == "notarget"){
if (substate == "attack" &amp;&amp; image_index == 19)
    {
    hitbox = script_execute(scr_create_hitbox, dir, 10, 20, 60, agi);
    }

if(hitbox != -1){
    with(hitbox){
        x = other.x + xOffset;
        y = other.y + yOffset;
    }
}
}

//target

if (state == "target") {
if (substate == "attack" &amp;&amp; image_index == 19)
    {
    hitbox = script_execute(scr_create_hitbox, targetFace, 10, 20, 60, agi);
    }

if(hitbox != -1){
    with(hitbox){
        x = other.x + xOffset;
        y = other.y + yOffset;
    }
}
}

//------------
//Heavy Attack Hit Box Creation
//-----------------


//no target


if (state == "notarget"){
if (substate == "heavyattack" &amp;&amp; image_index == 19)
    {
    hitbox = script_execute(scr_create_hitbox, dir, 10, 20, 60, 2*str);
    }

if(hitbox != -1){
    with(hitbox){
        x = other.x + xOffset;
        y = other.y + yOffset;
    }
}
}

//target

if (state == "target") {
if (substate == "heavyattack" &amp;&amp; image_index == 19)
    {
    hitbox = script_execute(scr_create_hitbox, targetFace, 10, 20, 60, 2*str);
    }

if(hitbox != -1){
    with(hitbox){
        x = other.x + xOffset;
        y = other.y + yOffset;
    }
}
}



//momentum
if(state == "notarget"){
if (p &gt;0){
    switch (dir){
    
    case("up"):
        y = y - p;
        p = p - 1;
    break;
       case("down"):
        y = y + p;
        p = p - 1;
    break;
       case("left"):
        x = x - p;
        p = p - 1;
    break;
       case("right"):
        x = x + p;
        p = p - 1;
    break;
    }}}
    
    
if(state == "target"){
        if (p &gt;0){
        direction = p1TargetDir;
        speed = p - 1;
        p=p-1;
    
    }
    }

if(p == 0) { speed = 0;}



//check for target

if(!instance_exists(p1_target) and substate == "guard")
    {
    state = "notarget";
    substate = "idle";

    }
    
    
    
if (hit == true)
{
    if(substate == "parry")
    {
       hit = false; 
      audio_play_sound(parry, 6, false);
      animation = "false";
      hitBy.owner.hitStun = 30;
    }
    
    else if(substate == "block"){
     hit = false; 
      audio_play_sound(block, 6, false);
       animation = "false";
       hitBy.owner.hitStun = 15;
    }
    
    else if(substate == "dodge"){
    
        hit = false;
    
    }
    
    else if(heavyArmor &gt; 0){
        
        hit = false;
        hp = hp - damagePending;
    
    
        }    
       
    
    else{
    
   
    hitStun = 10;
    hit = false;
    audio_play_sound(swordhit, 6, false);
    hp = hp - damagePending;
    }

}

//set health percentage

hppercent = (hp/hpmax) * 100;


//parry and block management

if (substate == "parry") {
    
    if(parryCounter &gt; 0) {
         parryCounter = parryCounter - 1;
        }
        
    else { substate = "block"}
    
    }
    
if (substate == "block") {

     if(blockCounter &gt; 0) {
         blockCounter = blockCounter - 1;
        }
        
    else { 
    
        switch(state) {
        
            case "notarget":
                substate = "idle";
                animation = "false";
            break;   
            
            case "target":
                substate = "guard"
                animation = "false";
            break; 
        }
        
        parryCounter = 10;
        blockCounter = 20;
    
    }


}

if(substate == "dodge"){
    
   if(dodgeCounter &gt; 0) {dodgeCounter = dodgeCounter -1;
    
    switch (dir) {
    
        case "up":
        y = y - 3;
        break;
        
        case "down":
        y = y + 3;
        break;
        
        case "left":
        x = x - 3;
        break;
        
        case "right":
        x = x + 3;
        break;
    
    
        }}
    
    
    else {
        switch(state) {
        
        
                case "notarget":
                    substate = "idle";
                    animation = "false";
                break;
                
                case "target":
                    substate = "guard";
                    animation = "false";
                break;
            }
        
    }
}

//----------------
//Heavy Armor Control
//----------------------

if(heavyArmorDelay &gt; 0){

    heavyArmorDelay = heavyArmorDelay - 1;
    
    if(heavyArmorDelay == 0){
    
            heavyArmor = 30;
    
        }

    }

if(heavyArmor &gt; 0){

    heavyArmor = heavyArmor - 1;

    }

//hitstun

if (hitStun &gt; 0) {

    hitStun = hitStun - 1;
    substate = "stun";
    
    if (hitStun == 0)
    {
        switch(state) {
        
        
                case "notarget":
                    substate = "idle";
                    animation = "false";
                break;
                
                case "target":
                    substate = "guard";
                    animation = "false";
                break;
            }
}
    
    
}


//-------------
//Grabbing
//-------------------

if(grabCounter &gt; 0){
    if(substate == "grab" and distance_to_object(p1_target) &lt; 60) {

    x = x + ceil((p1_target.x - x)/16);
    y = y + ceil((p1_target.y - y)/16);
 
    }
    
    grabCounter = grabCounter - 1;
    
    if(grabCounter == 0 and substate == "grab" and distance_to_object(p1_target) &lt; 20){
     p1_target.target.hitStun = 30;
     substate = "grabbing";
     grabbingCounter = 30;
    
    }
    
    if(grabCounter == 0 and substate!= "grabbing"){
          substate = "guard";
          animation = "false";
    }
    
 
}

//Break grab after a second

if(grabbingCounter &gt; 0 and substate == "grabbing"){
    grabbingCounter = grabbingCounter - 1;
    if(grabbingCounter == 0){
        substate = "guard";
        animation = "false"
    }
}

//Throw out of grab

if(substate == "grabbing"){
    if(left_held and square_held){
    p1_target.target.thrownLeft = true;
    p1_target.target.thrownCounter = 20;
    p1_target.target.hitStun = 20;
    substate = "guard";
    animation = "false";
    }
    
     if(right_held and square_held){
    p1_target.target.thrownRight = true;
    p1_target.target.thrownCounter = 20;
    p1_target.target.hitStun = 20;
    substate = "guard";
    animation = "false";
    }
    
     if(up_held and square_held){
    p1_target.target.thrownUp = true;
    p1_target.target.thrownCounter = 20;
    p1_target.target.hitStun = 20;
    substate = "guard";
    animation = "false";
    }
    
     if(down_held and square_held){
    p1_target.target.thrownDown = true;
    p1_target.target.thrownCounter = 20;
    p1_target.target.hitStun = 20;
    substate = "guard";
    animation = "false";
    }
  
    if(left_held and up_held and square_held){
    p1_target.target.thrownLeft = true;
    p1_target.target.thrownUp = true;
    p1_target.target.thrownCounter = 15;
    p1_target.target.hitStun = 15;
    substate = "guard";
    animation = "false";
    }
    
     if(right_held and up_held and square_held){
    p1_target.target.thrownRight = true;
    p1_target.target.thrownUp = true;
    p1_target.target.thrownCounter = 15;
    p1_target.target.hitStun = 15;
    substate = "guard";
    animation = "false";
    }
    
  if(left_held and down_held and square_held){
    p1_target.target.thrownLeft = true;
    p1_target.target.thrownDown = true;
    p1_target.target.thrownCounter = 15;
    p1_target.target.hitStun = 15;
    substate = "guard";
    animation = "false";
    }
    
     if(right_held and down_held and square_held){
    p1_target.target.thrownRight = true;
    p1_target.target.thrownDown = true;
    p1_target.target.thrownCounter = 15;
    p1_target.target.hitStun = 15;
    substate = "guard";
    animation = "false";
    }
    
    
}
  
//disallow this object to occupy the same place as other solid objects

if(!place_free(xprevious,y)){
    
    y = yprevious;
 
    } 
if(!place_free(x,yprevious)){
    
    x = xprevious;
     
    }
 

//this keeps sub image number while animating for changes in sprite directions while animating
if(substate == "heavyattack"){
    animatingImage = animatingImage + 1;
    image_index = animatingImage/2;
    }
    
if(substate == "lightattack"){
    animatingImage = animatingImage + 1;
    image_index = animatingImage;
    }
    
if(animation == "false") {
    animatingImage = 0;
    }
    
    

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
//different player states

States regardless of target switch: (Things you can do whether you’re targeting a unit or not)
Interact
dead
Quick item(animations)

Untarget states: (Things you can only do when you aren’t targeting a unit)
Idle: not moving and no inputs. Should have some idle animations(later)
Walking: basic movement, fairly quick, no stamina use
Run/Sprint: faster than walking, uses stamina(less/none when no baddies are around)
Sleeping: laying animation
sneaking
dialogue/shop
aoe and attack in front of you

Target states: (Things you can only do when you are targeting a unit)
Guard directions, top, middle, bottom
walk
sprint
attack
Dash
Cast
Shoot/throw



*/
depth = -y;
script_execute(scr_player_one_controls);

//Targeting script
 
if (l2_pressed &amp;&amp; !instance_exists(p1_target) &amp;&amp; ds_list_size(global.p1_enemies)!= 0)
    {
    instance_create(0,0,p1_target);
    substate = "guard";
    }

//Sprite control script

if (instance_exists(p1_target))
    {
    p1TargetDir = point_direction(x, y, p1_target.x, p1_target.y);
    }


    if (p1TargetDir &gt; 315 or p1TargetDir &lt;= 45)
        {
        targetFace = "right";
        }
        
    if (p1TargetDir &gt; 45 and p1TargetDir &lt;= 135)
        {
        targetFace = "up";
        }
        
    if (p1TargetDir &gt; 135 and p1TargetDir &lt;= 225)
        {
        targetFace = "left";
        }
        
    if (p1TargetDir &gt; 225 and p1TargetDir &lt;= 315)
        {
        targetFace = "down";
        }
    

script_execute(script_sprite_control, Testp1.state, Testp1.substate, Testp1.dir, Testp1.p1TargetDir, Testp1.targetFace, animation);





 /* -------------------------------------------------------------------------------------
 
 Directional key press controls (on press)
 
 ----------------------------------------------------------------------------------------*/
 
 //temporary startup animation for moving from idle.
 
 if (left_held &amp;&amp; substate == "idle" &amp;&amp; state == "notarget" and !animation)
 {
    substate = "startup";
      startUpCounter = 9;
    
 }
 
  if (right_held &amp;&amp; substate == "idle" &amp;&amp; state == "notarget" and !animation)
 {
    substate = "startup";
      startUpCounter = 9;
 }
 
  if (up_held &amp;&amp; substate == "idle" &amp;&amp; state == "notarget" and !animation)
 {
    substate = "startup";
    startUpCounter = 9;
 }
 
  if (down_held &amp;&amp; substate == "idle" &amp;&amp; state == "notarget" and !animation)
 {
    substate = "startup";
    startUpCounter = 9;
 }
 


 /* -------------------------------------------------------------------------------------
 
 Directional key press controls (hold)
 
 ----------------------------------------------------------------------------------------*/


if (left_held) //need to have if statement for when key is released to return to "idle" substate for both target and no target modes.
 {
 
 //switch statement for each possible main state, that is targeting or not targeting. There should be some overlapping actions that can be done in either.
  switch(state)
    {
    
    //notarget case
    
      case("notarget"):
        {
        
        //switch on substate for "notarget"
        
        switch(substate)
            {
             case "idle":
                
                //idle script. If you're pressing left and you're in the idle state, this script should be a start up animation. 
                 script_execute(scr_start_movement, dir, "left", x, y, animation);
                 break;
                 
            case "startup":
                
                script_execute(scr_start_movement, dir, "left", x, y, animation);
                break;
                
            case "walk":
                
                //walking script. check if dir is opposite key press. If so, stopping animation before began walking in dir. Otherwise, walk in dir immediately.
                 script_execute(scr_walk, dir, "left", x, y, animation);
                break;
                
            case "sprint":
                {
                //sprint script. Same as walking, but with more stopping animation, but maintain sprint(sprint will be toggle methinks)
                }
            case "sleep":
                {
                //sleep script. Wake up and begin walking.
                }
            case "sneak":
                {
                //sneak script. sneak in direction pressed
                }
            case "dialogue":
                {
                //dialouge script. movement keys should do nothing
                }
            case "menu":
                {
                //menu script. Navigate menus
                }
            case "hitstun":
                {
                //hitstun script. don't move left
                }
            }
        }
        
        
    //target case
      case("target"):
        {
        //switch on substate for "target"
            switch(substate)
                {
                
                  case "guard":
                    {
                     substate = "strafe";
                    }
                  case "strafe":
                    {
                     script_execute(scr_strafe, dir, "left", x, y, animation); 
                    }
                  case "sprint":
                    {
                    //sprint script
                    }
                  case "attack":
                    {
                   //attack script
                    }
                  case "dash":
                     {
                   //dash script
                    }
                  case "cast":
                    {
                        //cast script
                    }
                  case "shoot":
                    {
                    //shoot script
                    }
                }
        
        }   
        
        
    }
  }
    
if (up_held) //need to have if statement for when key is released to return to "idle" substate for both target and no target modes.
 {
 
 //switch statement for each possible main state, that is targeting or not targeting. There should be some overlapping actions that can be done in either.
  switch(state)
    {
    
    //notarget case
    
      case("notarget"):
        {
        
        //switch on substate for "notarget"
        
        switch(substate)
            {
             case "idle":
                {
                //idle script. If you're pressing left and you're in the idle state, this script should be a start up animation. 
                  script_execute(scr_start_movement, dir, "up", x, y, animation);
                  break;
                }
              case "startup":
                {
                script_execute(scr_start_movement, dir, "up", x, y, animation);
                break;
                }
                
            case "walk":
                {
                //walking script. check if dir is opposite key press. If so, stopping animation before began walking in dir. Otherwise, walk in dir immediately.
                 script_execute(scr_walk, dir, "up", x, y, animation);
                 break;
                }
            case "sprint":
                {
                //sprint script. Same as walking, but with more stopping animation, but maintain sprint(sprint will be toggle methinks)
                }
            case "sleep":
                {
                //sleep script. Wake up and begin walking.
                }
            case "sneak":
                {
                //sneak script. sneak in direction pressed
                }
            case "dialogue":
                {
                //dialouge script. movement keys should do nothing
                }
            case "menu":
                {
                //menu script. Navigate menus
                }
            case "hitstun":
                {
                //hitstun script. don't move left
                }
            }
        }
        
        
    //target case
      case("target"):
        {
        //switch on substate for "target"
            switch(substate)
                {
                
                  case "guard":
                    {
                   substate = "strafe";
                    }
                  case "strafe":
                    {
                      script_execute(scr_strafe, dir, "up", x, y, animation);
                    }
                  case "sprint":
                    {
                    //sprint script
                    }
                  case "attack":
                    {
                   //attack script
                    }
                  case "dash":
                     {
                   //dash script
                    }
                  case "cast":
                    {
                        //cast script
                    }
                  case "shoot":
                    {
                    //shoot script
                    }
                }
        
        }   
        
        
    }
 }  
    
  if (right_held) //need to have if statement for when key is released to return to "idle" substate for both target and no target modes.
 {
 
 //switch statement for each possible main state, that is targeting or not targeting. There should be some overlapping actions that can be done in either.
  switch(state)
    {
    
    //notarget case
    
      case("notarget"):
        {
        
        //switch on substate for "notarget"
        
        switch(substate)
            {
             case "idle":
                {
                //idle script. If you're pressing left and you're in the idle state, this script should be a start up animation. 
                  script_execute(scr_start_movement, dir, "right", x, y, animation);
                  break;
                }
             case "startup":
                {
                script_execute(scr_start_movement, dir, "right", x, y, animation);
                break;
                }
            case "walk":
                {
                //walking script. check if dir is opposite key press. If so, stopping animation before began walking in dir. Otherwise, walk in dir immediately.
                 script_execute(scr_walk, dir, "right", x, y, animation);
                 break;
                }
            case "sprint":
                {
                //sprint script. Same as walking, but with more stopping animation, but maintain sprint(sprint will be toggle methinks)
                }
            case "sleep":
                {
                //sleep script. Wake up and begin walking.
                }
            case "sneak":
                {
                //sneak script. sneak in direction pressed
                }
            case "dialogue":
                {
                //dialouge script. movement keys should do nothing
                }
            case "menu":
                {
                //menu script. Navigate menus
                }
            case "hitstun":
                {
                //hitstun script. don't move left
                }
            }
        }
        
        
    //target case
      case("target"):
        {
        //switch on substate for "target"
            switch(substate)
                {
                
                  case "guard":
                    {
                     substate = "strafe";
                    }
                  case "strafe":
                    {
                      script_execute(scr_strafe, dir, "right", x, y, animation); 
                    }
                  case "sprint":
                    {
                    //sprint script
                    }
                  case "attack":
                    {
                   //attack script
                    }
                  case "dash":
                     {
                   //dash script
                    }
                  case "cast":
                    {
                        //cast script
                    }
                  case "shoot":
                    {
                    //shoot script
                    }
                }
        
        }   
        
        
    }
  }  
 
if (down_held) //need to have if statement for when key is released to return to "idle" substate for both target and no target modes.
 {
 
 //switch statement for each possible main state, that is targeting or not targeting. There should be some overlapping actions that can be done in either.
  switch(state)
    {
    
    //notarget case
    
      case("notarget"):
        {
        
        //switch on substate for "notarget"
        
        switch(substate)
            {
             case "idle":
                {
                //idle script. If you're pressing left and you're in the idle state, this script should be a start up animation. 
                 script_execute(scr_start_movement, dir, "down", x, y, animation);
                 break;
                }              
             case "startup":
                {
                script_execute(scr_start_movement, dir, "down", x, y, animation);
                break;
                }
            case "walk":
                {
                //walking script. check if dir is opposite key press. If so, stopping animation before began walking in dir. Otherwise, walk in dir immediately.
                 script_execute(scr_walk, dir, "down", x, y, animation);
                 break;
                }
            case "sprint":
                {
                //sprint script. Same as walking, but with more stopping animation, but maintain sprint(sprint will be toggle methinks)
                }
            case "sleep":
                {
                //sleep script. Wake up and begin walking.
                }
            case "sneak":
                {
                //sneak script. sneak in direction pressed
                }
            case "dialogue":
                {
                //dialouge script. movement keys should do nothing
                }
            case "menu":
                {
                //menu script. Navigate menus
                }
            case "hitstun":
                {
                //hitstun script. don't move left
                }
            }
        }
        
        
    //target case
      case("target"):
        {
        //switch on substate for "target"
            switch(substate)
                {
                
                  case "guard":
                    {
                    substate = "strafe"
                    }
                  case "strafe":
                    {
                     script_execute(scr_strafe, dir, "down", x, y, animation);
                    }
                  case "sprint":
                    {
                    //sprint script
                    }
                  case "attack":
                    {
                   //attack script
                    }
                  case "dash":
                     {
                   //dash script
                    }
                  case "cast":
                    {
                        //cast script
                    }
                  case "shoot":
                    {
                    //shoot script
                    }
                }
        
        }   
        
        
    }
  }

 
 
if (triangle_pressed &amp;&amp; !animation){
 
 //switch statement for each possible main state, that is targeting or not targeting. There should be some overlapping actions that can be done in either.
  switch(state)
    {
    
    //notarget case
    
      case("notarget"):
        {
      
        scr_parry();
        }
        
        
    //target case
      case("target"):
        {
       
        scr_parry();
        
        }   
        
        
    }
  }
  
  

//dodge 

//if(keyboard_check_pressed(ord("S")) &amp;&amp; !animation){

if(circle_pressed and !animation) {
scr_dodge();
}

//grab

if(square_pressed &amp;&amp; !animation &amp;&amp; state == "target") {
        scr_grab();
    }


 //PVP test
 
 if (keyboard_check_pressed(ord("Z"))){
    if(PVP == false){
    if(instance_exists(Testp2)){
      ds_list_add(global.p1_enemies,Testp2);
      ds_list_add(global.p2_enemies, self);
        }
    if(instance_exists(Testp3)){
      ds_list_add(global.p1_enemies,Testp3);
      ds_list_add(global.p2_enemies, Testp3);
      ds_list_add(global.p3_enemies, self);
      ds_list_add(global.p3_enemies, Testp2);
      }
     if(instance_exists(Testp4)){
      ds_list_add(global.p1_enemies,Testp4);
      ds_list_add(global.p2_enemies, Testp4);
      ds_list_add(global.p3_enemies, Testp4);
      ds_list_add(global.p4_enemies, self);
      ds_list_add(global.p4_enemies, Testp2);
      ds_list_add(global.p4_enemies, Testp3);
      }
    PVP = true;
    }
    
    
    
 
    
     
else{

    PVP = false;
    ds_list_clear(global.p1_enemies);
    ds_list_clear(global.p2_enemies);
    ds_list_clear(global.p3_enemies);
    ds_list_clear(global.p4_enemies);
    } 

}
 
 
 
 
 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(spr_shadow, 1, x, y+15, .6, .8, 0, c_black, 0.5);
draw_self();
image_blend = c_red;
draw_healthbar(x - 20, y - 40, x + 20, y - 35, hppercent, c_black, c_red, c_green, 0, true, true);
draw_text_ext_transformed(x - 20, y - 40, string(hp),  2, 300, .5, .5, 0); 
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
